# 练习

## 练习1：解释`do_fork()`与`alloc_proc()`

为了正常运行lab5, 需要对lab4已有的函数进行一些改动. 我们在lab5的代码框架里标注了两个有改动的函数, 一处在`do_fork()`, 一处在`alloc_proc()`，请对每处改动解释一下如果lab5的代码里不做这个改动，那么现在或者将来会出什么bug，或者说会影响哪些功能。

## 练习2：编写`load_icode`函数

**do_execve**函数调用 `load_icode`（位于 `kern/process/proc.c`中）来加载并解析一个处于内存中的 ELF 执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好 `proc_struct` 结构中的成员变量 `trapframe` 中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的 `trapframe` 内容。

请在实验报告中简要说明你的设计实现过程。

请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU 是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过。

## 练习3：填写`copy_range`函数

创建子进程的函数` do_fork `在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过 `copy_range `函数（位于 `kern/mm/pmm.c`中）实现的，请补充 `copy_range` 的实现，确保能够正确执行。

请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

> [!NOTE|style:flat]
>
> Copy-on-write（简称 COW）的基本概念是指如果有多个使用者对一个资源 A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源 A 的指针，就可以该资源了。若某使用者需要对这个资源 A 进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源 A 的“私有”拷贝—资源 B，可对资源 B 进行写操作。该“写操作”使用者对资源 B 的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源 A。